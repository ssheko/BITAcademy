#include <stdio.h>
#pragma warning(disable:4996)	// 새문법을 쓰지 않겠다.

//int main()
//{
//	int a = 10;
//	int b = 6;
//
//	// 속도 빠르게, 메모리 하나 더 사용
//	int t;
//	t = a;
//	a = b;
//	b = t;
//
// XOR로 스왑
//	// 속도 느리지만 메모리 덜 소모
//	printf("%d %d\n", a, b);
//	a = a ^ b;	// a ^= b;	// t = a^b; -> b = t^a;    a = t^b;
//	b = a ^ b;
//	a = a ^ b;
//	printf("%d %d\n", a, b);
//	getchar();
//}
//

/* 비트 연산자 */
//main()
//{
//	int a = 0xA;	// 1010
//
//	// bit shift
//	//a = a | 4;		// 1110 E
//	// 더 많이 사용
//	//a = a | (1 << 2);
//
//	//a = a | (1 << 16);
//
//	//a |= (1 << 16) + (1 << 2);
//
//
//
//	//// bit check
//	//if (a & 8)	// check는 if와 &가 결합되어 사용됨.
//	//	puts("true");
//	//else
//	//	puts("false");
//
//	//// 16번째 비트가 1인지 아닌지 검사
//	//if (a & (1<<16))
//	//	puts("true");
//	//else
//	//	puts("false");
//
//
//	//// bit mask
//	//a = 0x12345678;
//	//// a가 가진 45부분을 mask해서 출력
//	//a &= 0x45000;
//
//
//
//	//// bit clear &~
//	//a = 0x12345678;	// 0111 1000
//
//	////a = a & ~16;
//	////a &= ~(1 << 21);
//	//a &= ~((1 << 21) + (1 << 3));
//
//	//printf("%x\n", a);
//
//
//	//// 문제
//	///** int a = 0xA5
//	//	int *p를 이용해 a의 내용들을 변경하고 출력하시오
//	//	(비트는 우측에서 0부터 시작한다)
//	//	1. 6번 비트가 0인지 1이면 ture 0이면 false
//	//	2. 3번 비트와 1번 비트를 1로 set하고 출력
//	//	3. 1번 비트와 2번 비트를 0으로 clear하고 출력
//	//	4. 5,6,7번 비트를 추출하여 값을 출력
//	//**/
//	//a = 0xA5;
//	//int *p = &a;
//	//if (a & (1 << 6))	// false
//	//	puts("true");
//	//else
//	//	puts("false");	
//
//	//*p |= (1 << 3) + (1 << 1);
//	//printf("%x\n", a);	// AF
//
//	//*p &= ~((1 << 1) + (1 << 2));
//	//printf("%x\n", a);	// A9
//
//	//*p &= 0xE0;		// A0
//	//printf("%x\n", a);
//
//	//a = 0x12345678;
//	// 78563412 출력
//	/*int b = a & 0x12345600;
//	printf("%x %x\n", a, b);
//	a = a << 24;
//	b = b >> 8;
//	a |= b;
//	printf("%x %x\n", a, b);*/
//	//	a = (a & 0xff) << 24 | (a & 0xff00) << 8 |
//	//		(a>>8)&0xff00 | (a>>24)&0xff; 	// (a&0xff000000) >> 24 | (a&0xff0000) >> 8
//	//
//	//
//	//
//	//	// 문제
//	//	/*
//	//	어떤 값이 입력되든지
//	//	4의 배수 형태로 출력되게
//	//	--> 3을 더하고 3을 지워라
//	//	*/
//	////	int x = 7;
//	////	//scanf("%d", &x);
//	////	if (x % 4 == 0)
//	////		return;
//	/////*
//	////	if (x / 4 > 0)
//	////		x &= (1 << ((x / 4)+2));
//	////	else*/
//	////
//	////	x |= (1 << ((x / 4) + 2));
//	////	if (x & 0x10 || x & 0x1)
//	////		x &= ~((1<<1) + (1<<0));
//	//	int x = 7;
//	//	x += 3;
//	//	x &= ~0x11;
//	//
//	//
//	//
//	//
//	//	// 문제
//	//	/*
//	//	10진수 num의 우측 n비트에서 w번째 비트까지 값을 추출하여 10진수로
//	//
//	//	십진수 입력: 684
//	//	n수 입력: 4
//	//	w수 입력: 3
//	//
//	//	0010 1010 1100
//	//	0010 1010 1100
//	//	결과 출력: 5
//	//	*/
//	//	int num = 684, n = 4, w = 3;
//	///*
//	//	num = num >> n;
//	//	int mask = 0xff << w;
//	//	mask = ~mask;
//	//	num &= mask;*/
//	//	printf("%x\n", num >> (n-1) & ~((~0) << w));
//	//	// ((~0)): 1111 1111
//	//	// << w : 1111 1000
//	//	
//	//	
//	//	// 반복문의 3가지 필수 조건: 초기값, 조건, 증감
//	//
//	//	int sum = 0, num = 1;	// 초기값
//	//	// goto문을 사용하여 1 ~ 10까지의 합을 출력
//	//RED:
//	//		sum += num;
//	//		num++;	// 증감
//	//	
//	//
//	//	if (num <= 10)	// 조건
//	//		goto RED;
//	//
//	//	printf("%d\n", sum);
//	//
//	//
//	//
//}
//
//main()
//{
//	/*
//	1. 1~10사이의 수가 입력되면 '통과', 아니면 '불통'
//	2. 입력문자가 A~Z면 '대문자' 출력, a~z면 '소문자' 출력
//	3. 대문자가 입력되면 소문자로 소문자면 대문자로 출력	// a 97 A 65
//	*/
//
//	// 1
//	int input = 0;
//	scanf_s("%d", &input);
//	getchar();
//
//	if (input >= 1 && input <= 10)
//		printf("통과\n");
//	else
//		printf("불통\n");
//
//	// 2
//	char inputchar;
//	scanf_s("%c", &inputchar);
//	getchar();
//	if (inputchar >= 'a' && inputchar <= 'z')
//		printf("소문자\n");
//	if (inputchar >= 'A' && inputchar <= 'Z')
//		printf("대문자\n");
//
//	// 3
//	// A 0100 0001
//	// a 0110 0001
//	if (inputchar >= 'a' && inputchar <= 'z')
//		printf("%c\n", inputchar & ~32);	// inputchar - 'a' + 'A'
//	if (inputchar >= 'A' && inputchar <= 'Z')
//		printf("%c\n", inputchar | 32);
//
//	// 대문자 <-> 소문자
//	printf("%c\n", inputchar ^ (1 << 5));
//}


/* 배열 */
//#define A 4
//
//main()
//{
//	int a[100];
//	/*
//	1. 위 a배열에 0~99까지 넣고 출력
//	2. 위 a배열에 1~100까지 넣고 출력
//	3. 위 a배열에 0부터 시작하는 짝수값만 넣고 출력
//	4. 위 a배열에 1~100까지 넣고 3의 배수와 7의 배수만 출력
//	5. 위 a배열에 짝수번째는 99부터 시작되는 홀수 다운카운팅
//				  홀수번째는 0부터 시작되는 짝수 업카운팅
//		0  1  2  3  4  5  6  7  
//		[99][0][97][2][95][4][93][6][][][]
//	6. 위 a배열에 1~100까지 넣고 54가 나오기 전까지만 출력
//		1, 2, 3, ... 52, 53
//	7. 입력된 두 수에 대하여 작은 수부터 큰 수까지 출력
//		ex) 3 7 -> 3 4 5 6 7
//			9 6 -> 6 7 8 9
//	 */
//#if A == 1
//	// 1
//	for (int i = 0; i < 100; i++) {
//		a[i] = i;
//		printf("%d ", a[i]);
//	}
//#elif A == 2
//	// 2
//	for (int i = 1; i <= 100; i++) {
//		a[i] = i;
//		printf("%d ", a[i]);
//	}
//
//#elif A == 3
//	// 3
//	for (int i = 0; i < 100; i++) {
//		if (i % 2 == 0) {
//			a[i] = i;
//			printf("%d ", a[i]);
//		}
//	}
//
//#elif A == 4
//	// 4
//	for (int i = 0; i < 100; i++)
//		a[i] = i;
//
//	for (int i = 0; i < 100; i++) {
//		if(a[i] % 3 == 0 && a[i] % 7 == 0)
//			printf("%d ", a[i]);
//	}
//
//#elif A == 5
//	// 5
//	/*위 a배열에 짝수번째는 99부터 시작되는 홀수 다운카운팅
//		홀수번째는 0부터 시작되는 짝수 업카운팅
//		0  1  2  3  4  5  6  7
//		[99][0][97][2][95][4][93][6][][][]*/
//	for (int i = 0; i < 100; i++){
//		// 짝수
//		if (i % 2 == 0) 
//			a[i] = 99 - i;
//		
//		else 
//			a[i] = i - 1;
//
//		printf("%d ", a[i]);
//		
//	}
//
//#elif A == 6
//	//6. 위 a배열에 1~100까지 넣고 54가 나오기 전까지만 출력
//	//	1, 2, 3, ... 52, 53
//
//	for (int i = 0; i < 100; i++)
//		a[i] = i;
//
//	for (int i = 0; i < 100; i++) {
//		if (a[i] < 54)
//			printf("%d ", a[i]);
//	}
//
//
//#elif A == 7
//	//	7. 입력된 두 수에 대하여 작은 수부터 큰 수까지 출력
//	//	ex) 3 7 -> 3 4 5 6 7
//	//	9 6 -> 6 7 8 9
//	int c, b;
//	scanf_s("%d %d", &c, &b);
//
//	if (c < b) {
//		for (int i = c; i <= b; i++)
//			printf("%d ", c++);
//	}
//	else {
//		for (int i = b; i <= c; i++)
//			printf("%d ", b++);
//	}
//#endif
//
//}

/* 1차원 배열로 문자열 처리 가능 */
//main() {
//	char arr[] = "abc";			// 4	문자열은 마지막에 null 추가
//	char brr[4] = "abc";		// 4
//	char crr[] = { 'a', 'b', 'c' };		// 3
//	char drr[4] = { 'a', 'b', 'c' };	// 4	// 마지막 요소가 초기화되지 않았으므로 null이 들어감 (초기화리스트의 개수가 모자를 때 나머진 0이 들어감)
//
//	char err[2][10] = {"aaa", "bbbbb"};
//
//	printf("%s\n", arr);
//	printf("%s\n", brr);
//	printf("%s\n", crr);	// \n, 즉 null이 나올때까지 출력하는 것이라 null이 없는 crr은 뒤에 쓰레기값이 함께 출력됨
//	printf("%s\n", drr);
//	printf("%s\n", err[0]);
//	printf("%s\n", err[1]);
//}

/* 배열 문제 */
/* 
1차원 배열
int a[5] = {3,4,1,5,2};
a 배열 안의 가장 큰 값인 5를 찾아 출력

2차원 배열 
int a[2][3] = {1,2,3,4,5,6};
배열 a의 값을 행과 열의 합으로 구하여 다음과 같이 출력
1 2 3 | 6
4 5 6 | 15
------
5 7 9
*/
//main()
//{
//	int a[5] = { 3,4,1,5,2 };
//	int b[2][3] = { 1,2,3,4,5,6 };
//
//	int max = a[0];
//	for (int i = 0; i < 5; i++) {
//		if (max < a[i])
//			max = a[i];
//	}
//	printf("%d\n", max);
//
//	int col = 3, row = 2;
//	int sum = 0;
//	for (int j = 0; j < row; j++) {
//		for (int i = 0; i < col; i++) {
//			printf("%d ", b[j][i]);
//			sum += b[j][i];
//		}
//		printf("| %d\n", sum);
//		sum = 0;
//	}
//
//	printf("----------\n");
//
//	for (int j = 0; j < col; j++) {
//		for (int i = 0; i < row; i++) {
//			sum += b[i][j];
//		}
//		printf("%d ", sum);
//		sum = 0;
//	}
//
//}


/* 간접 연산자 */	
//int get_num(void) {
//	return 40;
//}
//main()
//{
//	int a = 10; // 변수를 정의하면서 초기화
//
//	a = 20; // 대입연산자를 이용한 대입
//
//	scanf("%d", &a);	// 키보드입력(표준입력) 통한 입력 30
//
//	a = get_num(); // 함수의 리턴값을 a에 대입 40
//
//	*&a = 50;
//
//	printf("%d %d\n", a, *&a);
//}

/* 다른 메모리 주소를 담는 변수 = 포인터 */
//main()
//{
//	int a = 10;
//	int *pa; // int형 메모리의 주소를 담는 변수 pa
//
//	pa = &a;	// a의 주소를 pa에 대입
//
//	//scanf("%d", &a);
//	//printf("%d\n", a);
//
//	//// pa를 이용해서 a에 scanf와 printf 해보시오.	
//	//scanf("%d", pa);
//	//printf("%d %d\n", *pa, a); // *pa = *&a
//
//	int b = 5;
//	int *pb = &b;
//
//	int* tmp= pa;
//	*pa = *pb;
//	*pb = tmp;
//
//
//	printf("%d %d\n", a, b); // *pa = *&a
//
//}

