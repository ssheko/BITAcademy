1.3.1 사용자 정의 데이터 타입
* 사용자 정의 데이터 타입을 사용하는 이유
1. 헤더파일만 바꿔도 될 수 있게. 소스코드는 바꾸지 않아도 되도록.
2. 다른 OS가 아니더라도 HW 발전은 계속됨. 기본 데이터타입을 쓸 경우 비트 체제가 맞지 않을 수 있으니까.

SBCS (single byte character set) 1 byte만 사용하는 것
DBCS (double byte characted set) 2 byte 사용
Windows: MBCS (Multi byte character set) 윈도우의 기본 인코딩 체계 -> 리눅스와 호환이 안 됨
프로젝트 속성 - 일반 - 문자 인코딩 설정 - (기본) 유니코드. (MBCS도 별도로 있음)

* UNICODE 전 세계 언어 표준화
2byte ~ 4byte까지 쓰는 나라별 버전이 다 다름.
한글은 2byte면 충분. UTF-8 버전 사용. (2byte 체계)
UNICODE를 사용해야 윈도우, 리눅스 등등에서 한글이 깨지지 않는다.

char* str = "김개";
char* str = L"김개";	// UNICODE type으로 converting해서 str에 넣어줌.
str -> 100번지
str+1 -> 101번지. char는 1 byte니까
str+1을 할 경우 한글을 제대로 읽어올 수 없음. 한글은 2byte라서

wchar_t* str = L"김개";
wchar_t+1 -> 2byte씩 점프함
*(wchar_t+1) = "개"

=================================================================p. 4
TCHAR을 사용할 경우 사용 환경에 따라 알아서 type conversion이 됨.
LPTSTR
-> L: Long
-> P: Pointer
-> T: T 매크로 사용

LPCTSTR
-> C: Const 타입

Q) LPSTR
-> char*

=================================================================p. 5
LPTSTR buf = TEXT("홍길동");	// _TEXT("홍길동"); 도 가능
-> char* buf = "홍길동";
-> wchar_t* buf = L"홍길동";

1.3.3. 핸들
객체를 내부적으로 구분할 수 있는 key값 부여.
윈도우 상에서 제공하는 어떤 객체든지 만들면 내부적으로 handle 번호를 부여하고,
이 handle 번호로 각 객체에 접근.
윈도우에 대한 핸들을 받을 땐 HWND로 받기

=================================================================p. 6
인스턴스 (skip)

1.3.5. 리소스
리소스를 스크립트 파일로 정의하고, 관리.
-> 이유: 빌드를 할 때 리소스를 바이너리 파일로 같이 컴파일해서 실행할 때 같이 넣어주려고.
(skip)

