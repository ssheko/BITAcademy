1.3.1 사용자 정의 데이터 타입
* 사용자 정의 데이터 타입을 사용하는 이유
1. 헤더파일만 바꿔도 될 수 있게. 소스코드는 바꾸지 않아도 되도록.
2. 다른 OS가 아니더라도 HW 발전은 계속됨. 기본 데이터타입을 쓸 경우 비트 체제가 맞지 않을 수 있으니까.

SBCS (single byte character set) 1 byte만 사용하는 것
DBCS (double byte characted set) 2 byte 사용
Windows: MBCS (Multi byte character set) 윈도우의 기본 인코딩 체계 -> 리눅스와 호환이 안 됨
프로젝트 속성 - 일반 - 문자 인코딩 설정 - (기본) 유니코드. (MBCS도 별도로 있음)

* UNICODE 전 세계 언어 표준화
2byte ~ 4byte까지 쓰는 나라별 버전이 다 다름.
한글은 2byte면 충분. UTF-8 버전 사용. (2byte 체계)
UNICODE를 사용해야 윈도우, 리눅스 등등에서 한글이 깨지지 않는다.

char* str = "김개";
char* str = L"김개";	// UNICODE type으로 converting해서 str에 넣어줌.
str -> 100번지
str+1 -> 101번지. char는 1 byte니까
str+1을 할 경우 한글을 제대로 읽어올 수 없음. 한글은 2byte라서

wchar_t* str = L"김개";
wchar_t+1 -> 2byte씩 점프함
*(wchar_t+1) = "개"

=================================================================p. 4
TCHAR을 사용할 경우 사용 환경에 따라 알아서 type conversion이 됨.
LPTSTR
-> L: 특별한 의미 x
-> LP: Pointer
-> T: T 매크로 사용

LPCTSTR
-> C: Const 타입

Q) LPSTR
-> char*

=================================================================p. 5
LPTSTR buf = TEXT("홍길동");	// _TEXT("홍길동"); 도 가능
-> char* buf = "홍길동";
-> wchar_t* buf = L"홍길동";

1.3.3. 핸들
객체를 내부적으로 구분할 수 있는 key값 부여.
윈도우 상에서 제공하는 어떤 객체든지 만들면 내부적으로 handle 번호를 부여하고,
이 handle 번호로 각 객체에 접근.
윈도우에 대한 핸들을 받을 땐 HWND로 받기

=================================================================p. 6
인스턴스 (skip)

1.3.5. 리소스
리소스를 스크립트 파일로 정의하고, 관리.
-> 이유: 빌드를 할 때 리소스를 바이너리 파일로 같이 컴파일해서 실행할 때 같이 넣어주려고.
(skip)


=================================================================실습
프로젝트 생성 - C++ - Windows 데스크톱 - Windows 데스크톱 마법사
(응용 프로그램 종류)Windows 응용 프로그램 선택, 빈 프로젝트 선택


=================================================================p. 11
* 함수 호출 규약
stack frame: 함수 호출할 때마다 만드는 스택
인자 값 넘겨주는 함수 호출
C에서 표준으로 쓰는 cdecl방식은 인자의 맨 끝에 있는 것부터 순서대로 해당 스택에 쌓아둔다.
ex) Add(a,b,c)	--> 스택 [ a b c ] (맨 아래)
Main은 호출을 하는 것. -> Caller
Add는 호출을 당함.      -> Callee
Caller가 Callee의 스택에 매개변수를 차곡차곡 쌓아줌.

스택을 어떻게 비우느냐? 이게 호출규약.
Callee의 스택 프레임을 Caller가 치움 -> cdecl 방식. (본인이 아닌 Caller가 굳이 치움. 복잡)
가변인자 방식을 쓰기 때문에 Callee쪽에서 몇 개의 인자를 줬는지 모름. 하지만 Caller쪽에서 사용한 인자 개수를 알고 있으니까 이를 이용하는 것.

가변인자를 쓰지 않는 stdcall방식.
Callee가 본인 스택을 비움. 로직이 훨씬 쉽다.
(타입) (호출규약) (함수이름)	-> stdcall 방식.
ex) int WINAPI _tWinMain

윈도우는 기본적으로 message driven 방식. 외부에서 이벤트 메세지가 들어오면 메세지에 따라 동작.
OS 자체 내에서 System Queue가 존재. OS 입장에서 받아들이는 모든 이벤트가 들어옴. (키보드, 마우스 등등에서)
애플리케이션 자체가 하나의 thread.
각 애플리케이션마다 하나의 스레드가 존재. 스레드마다 thread Queue가 존재.
System Queue에서 Thread Queue로 하나씩 보냄.


=================================================================p. 34

메세지 종류는 필요한 것만 msdn에서 찾아 추가할 것. 외우지 말 것.

4.2. 메세지 큐
queue message, non-queue message (비큐) 두 종류

=================================================================p. 36
WM_CREATE 메세지는 메세지 큐에 놓이지 않고 직접 윈도우 프로시져에 전달된다.
--> 비큐 메세지 (non-queue message)

입력 메세지 제외, 대부분의 메세지가 비큐 메세지.


=================================================================p. 47
DC (Device Context)
선을 하나 긋는데도 선의 두께, 선의 색깔, 좌표 등등의 속성을 정해주기 귀찮으니
해당 장치에 DC를 가져오는 방법을 사용.
출력을 위한 기본 정보를 DC가 다 가지고 있다.
특정 속성만 바꿔서 쓸 수 있어서 편리함.

DC 핸들은 사용하는 순간에 쓰고, 제거해야 한다.
어떤 변수에 DC를 담고 있을 수 없음.

* 윈도우 전체, 클라이언트 영역
ex) 메모장에서 내용을 쓸 수 있는 부분 = 클라이언트
메모장의 상단 바부터 메뉴, 내용 쓰는 부분 = 윈도우 전체


=================================================================p. 48
* 무효화 영역 (Invalid Region)
윈도우가 다른 윈도우에 감춰진 부분. 다시 그려야 하는 영역


=================================================================p. 49
WM_PAINT
WM_TIMER
-> flag time message

다른 메세지는 메세지 큐에 들어옴.
위 두 메세지는 flag
getMessage 함수; 메세지큐에 있는 메세지를 모두 꺼내면 WM_PAINT가 있는지 확인. 그 후 WM_TIMER 확인.
WM_PAINT는 일반메세지보다 우선순위가 낮다.
WM_TIMER는 그보다 더 낮다.
WM_PAINT를 만나야만 SHOW WINDOW에서 화면에 윈도우가 그려짐.
윈도우가 생성되면서 메세지 큐에 있는 메세지를 처리하는 게 느리니까 
업데이트 윈도우 함수를 SHOW WINDOW 함수 다음에 썼었음.
업데이트 함수는 메세지 큐 확인을 window procedure에 직접 던졌다.
하지만 이제 하드웨어 성능이 좋아져서 업데이트를 해 줄 필요 없음.

메세지 큐에 전송된 이벤트가 많을수록 WM_PAINT, WM_TIMER를 확인하는 시간이 그만큼 늦어짐.
따라서 정교한 시간측정이 필요할 경우 WM_TIMER 사용 지양 권장.

무효화되는 상황이 변할 수 있는 상황 (ex; 스크롤 다운 등)
wm_paint는 paint structure 영역에 있는 좌표만 바뀐다.
BeginPaint() : WM_PAINT flag를 off시킴.
BeginPaint(hWnd, &ps)	// ps: 무효화 영역의 좌표값이 들어감.

=================================================================p. 50
-	DC를 만들고 UpdateRegion을 DC의 Cliping 영역으로 지정한다
--> 즉 다시 그리기 영역으로 지정

-	Caret 이 있을 경우 그리기 전에 Hide하고 EndPaint() 에서 Show 한다.
--> Caret
텍스트 환경에서 커서가 깜빡거리는 것처럼 그림을 그려나갈 때 다음 위치를 나타내주는 것을 의미.

PAINTSTRUCT
--> 외우려고 하지 마라. 필요할 때 msdn 참고할 것

rcPaint를 최소화할 수록 더 속도가 빨라진다.


=================================================================p. 51

