================================================================== 03.p.31 Top-K Query
SELECT ROWNUM, ENAME, SAL
FROM EMP
WHERE HIREDATE LIKE '81%' AND ROWNUM < 4
ORDER BY SAL DESC


SELECT ROWNUM, ENAME, SAL
FROM (SELECT * 
	FROM EMP 
	WHERE HIREDATE LIKE '81%'
	ORDER BY SAL DESC)
WHERE ROWNUM < 4
	-> rownum이 3개만 출력되도록.

DB가 커질수록 당연히 select * 쿼리문은 지양해야 함.


UNION: 중복 제거, 전체 출력
UNION ALL: 중복 허용, 전체 출력

SELECT ENAME FROM EMP
UNION
SELECT DNAME FROM DEPT
	-> UNION: 칼럼 갯수만 맞으면 무조건 입력시킴


SELECT EMPNO, ENAME, JOB
FROM EMP
WHERE JOB = 'CLERK'
UNION
SELECT EMPNO, ENAME, JOB
FROM EMP
WHERE JOB = 'SALESMAN'
	-> 직업이 CLERK 혹은 SALESMAN인 사람 출력

SELECT EMPNO, ENAME, JOB
FROM EMP
WHERE DEPTNO = 30
MINUS
SELECT EMPNO, ENAME, JOB
FROM EMP
WHERE JOB = 'CLERK'
	-> DEPTNO = 30인 사람 중 직업이 CLERK인 사람 제외하고 출력

SELECT EMPNO, ENAME, JOB
FROM EMP
WHERE JOB = 'MANAGER'
INTERSECT
SELECT EMPNO, ENAME, JOB
FROM EMP
WHERE DEPTNO = 30
	-> JOB = 'MANAGER'이면서 DEPTNO = 30인 사람 출력

================================================================== 03.p.33 RANK
SELECT SAL, ENAME,
	RANK() OVER (ORDER BY SAL DESC) AS RANK,
	DENSE_RANK() OVER (ORDER BY SAL DESC) AS DENSE_RANK,
	ROW_NUMBER() OVER (ORDER BY SAL DESC) AS ROW_NUMBER,
	ROWNUM AS "ROWNUM"
FROM EMP
	-> "": alias 쓸때만 사용.
	ROWNUM: keyword

================================================================== 05.p.05 테이블 생성
CREATE TABLE book(
	book_id NUMBER(5),
	title	VARCHAR2 (50),
	author	VARCHAR2 (10),
	pub_date	DATE
)


SELECT * FROM EMP WHERE ROWNUM = 3;
	-> 하나씩 뽑아낼 때마다 ROWNUM = 1이기 때문에 ROWNUM =3인 게 절대 나올 수 없다.

SELECT OBJECT_NAME FROM ALL_OBJECTS WHERE OWNER = 'C##SCOTT' AND OBJECT_TYPE = 'TABLE';
	-> 유저의 쿼리문을 볼 때

================================================================== 05.p.15 제약조건 1
* 인덱스
PK 설정하면 자동으로 인덱스(목차) 생성됨.
PK를 기준으로 데이터 sorting. 정렬이 끝나면 인덱스를 만든다.
ex) A #1	 B #5   C #10
	-> B로 시작하는 값을 찾을 경우 5번째 줄로 이동해 검색.

================================================================== 05.p.16 제약조건 2
* 복합 컬럼
두, 세개 컬럼을 묶어서 식별 가능. PK 여러 개 설정 가능.

rate NUMBER CHECK (rate IN (1,2,3,4,5))
	-> NUMBER 값에 1,2,3,4,5 이외의 값이 들어오면 에러 발생

================================================================== 05.p.17 실습 1
CREATE TABLE AUTHOR(
	AUTHOR_ID NUMBER(10) CONSTRAINT PK_AUTHOR PRIMARY KEY,
	AUTHOR_NAME VARCHAR2(100) CONSTRAINT NOT_NULL_AUTHOR NOT NULL,
	AUTHOR_DESC VARCHAR2(500)
)

	-> primary key도 자동으로 not null 설정됨
	-> CONSTRAINT [제약조건 이름]


SELECT UC.CONSTRAINT_NAME, UC.TABLE_NAME,
UCC.COLUMN_NAME,
	UC.CONSTRAINT_TYPE, UC.R_CONSTRAINT_NAME,
UC.SEARCH_CONDITION
FROM USER_CONSTRAINTS UC JOIN USER_CONS_COLUMNS UCC
	ON UC.CONSTRAINT_NAME = UCC.CONSTRAINT_NAME
WHERE UC.TABLE_NAME = 'AUTHOR'
	-> CONSTRAINT NAME 확인

제약조건 타입
P: PRIMARY KEY
U: UNIQUE KEY
C: CHECK
R: FOREIGN KEY

================================================================== 05.p.18 실습 2
ALTER TABLE BOOK MODIFY (BOOK_ID CONSTRAINT PK_BOOK PRIMARY KEY);
	-> BOOK_ID에 PRIMARY KEY 제약조건 설정.

ALTER TABLE BOOK ADD (AUTHOR_ID NUMBER(10));

ALTER TABLE BOOK ADD CONSTRAINT FK_BOOK_AUTHOR FOREIGN KEY(AUTHOR_ID) REFERENCES AUTHOR(AUTHOR_ID);
	-> book 테이블에 author 테이블의 author_id 컬럼을 추가하게 되면 foreign key 제약조건을 걸어줘야 함.




ALTER TABLE EMP ADD PRIMARY KEY (EMPNO);

ALTER TABLE DEPT ADD PRIMARY KEY (DEPTNO);

ALTER TABLE EMP ADD FOREIGN KEY (DEPTNO) REFERENCES DEPT(DEPTNO);


================================================================== 06.p.03 INSERT
INSERT INTO AUTHOR
VALUES (1, '박경리', '토지 작가 ');

INSERT INTO AUTHOR(author_id, author_name)
VALUES (2, '이문열');

INSERT INTO department_usa
SELECT department_id, department_name
FROM deptments
WHERE department_name = 'IT';


================================================================== 06.p.04 UPDATE
UPDATE emp
SET sal = sal + 100, comm = 0
WHERE deptno = 10;

UPDATE emp SET sal = sal * 1.1;

UPDATE emp SET sal = (SELECT MAX(SAL) FROM EMP)
where job = (SELECT JOB FROM EMP WHERE ENAME = 'SCOTT');

SHOW AUTOCOMMIT;
SET AUTOCOMMIT ON;
SHOW AUTOCOMMIT;
SET AUTOCOMMIT OFF;
SHOW AUTOCOMMIT;

	-> COMMIT할 경우, COMMIT 전까지의 기록으로 ROLLBACK할 수 없음.
	-> commit하면 데이터가 다 사라진다.


create global temporary table temp_tab (col1 number, col2 char(15)) on commit delete rows
	-> 임시 테이블 생성

insert into temp_tab (col1, col2) values (1, '가나다라');


================================================================== 06.p.08 TRNASACTION
* Transaction
DB에서 하나의 작업으로 처리되는 논리적 작업 단