1. 열거, enum 타입
enum 열거형식명 : 기반자료형 {상수1, 상수2, 상수3 ....}
첫번째 열거 형식 요소에는 0부터 들어가고 순차적으로 1씩 증가한다.
열거 형식의 각 요소는 서로 중복되지 않는 값을 갖고 있다는데 의미가 있다.
열거 형식은 변수가 아니라 새로운 형식이다.
원하는 값을 직접 넣으면 해당 값으로 대입되며 다음 요소는 1추가된 값이다.

   day28 31줄, 137줄
	(int)ColorCode.RED
	ColorCode.Green
	ColorCode cCode = ColorCode.RED;
	cCode == ColorCode.BLUE		// FALSE
	
2. 보기 코드. 실행 결과 적기. ? 들어간 것 관련. (nullable)
-Nullable 형식
형태 : 데이터형식? 변수이름;
ex) int? a;
변수가 null값을 수용가능하도록 만드는 형식이다.
컴파일하면 .NET의 Nullable<T> 타입으로 변환된다.
Nullable Type (int?)을 일반 Value Type (int)로 변경하기 위해서는 Nullable의 .Value 속성을 사용한다.

모든 Nullable 형식은 HasValue와 Value 두가지 속성을 가진다.
HasValue : bool 값을 반환. 해당 Nullable 변수가 값을 가지는지 판단해 null이면 false를 반환. 값을 가지면 true를 반환
Value : 변수 값을 받아온다. 단, null 상태의 변수에 value로 값을 받아오려고 시도하면 InvalidOperationException 예외 처리됨

-Null 조건부 연산자
형태: ?.
ex) obj?.member
객체의 멤버에 접근하기 전에 해당 객체가 null인지를 검사하여 객체가 null일 경우 null을 반환하고 그렇지 않은 경우
. 뒤에 지정된 멤버를 반환한다.
유사형태 ?[] : 동일 기능을 수행하는 연산자. 객체의 멤버 접근이 아닌 배열 같은 컬렉션 객체의 첨자를 이용한 참조에 사용

-Null 병합 연산자
형태:  ?? 
ex) a ?? b
왼쪽 피연산자 a가 null이 아닐경우 a를 반환. null일 경우 b를 반환한다.

   day28 153줄, 290줄
	1. nullable 연산자
		int? a = null;	// 기본타입 + ? => 기본타입이 null값 가질 수 있음.
`		a.HasValue	// null이면 false, 아니면 true
   day28 290줄
	2. ArrayList
		ArrayList a = null;
		a?.Add("C++");	// null이 아니면 ? 뒤를 실행. null일 경우 a를 리턴 (null값)

		a = new ArrayList();
		a?.Add("C++");	// a 리스트에 C++이 추가됨.

	3. null 병합 연산자
		int? num = null;
		num ?? 0		// num이 null이 아니면 왼쪽(num), null이면 오른쪽(기본값인 0)


3. 가장 조상. (상속의 최상위)
모든 데이터 형식 (기본 데이터 형식, 복합 데이터 형식, 사용자 생성 형식)이 자동으로 object 형식으로부터 상속받게 해
C#에서는 모든 데이터를 object로 다룰수 있게 됨. 즉, object 형식이 모든 데이터 형식의 조상

   day29 137줄, 163 줄
	class Parent
	{
		public Parent(string name) {}
	}
	class Child : Parent
	{
		public Child(string name) : base(name) {}	// 부모 생성자 호출
	}

4. C# 엔트리 포인트. (메인). main형태 (메인의 여러가지 형태가 있을 수 있다.)
엔트리 포인트 : 진입점이란 뜻으로 프로그램 진입점은 main 메소드이다.
static void Main(string[] args)
메인 메소드 반환 형식으로 가능한것은 아래와 같다.
void , int, Task, Task<int> 

5. C#과 .NET Framework의 비교표 (교재에 있는 것) (6쪽)
   교재 6쪽
	bool	System.Boolean
	float	System.Single
	int	System.Int32	// MinValue, MaxValue
	uint	System.UInt32
	long	System.Int64
	short	System.Int16

6. ? 관련. int 기본 데이터 타입이 내부적으론 객체. Int. 의 여러 property 중 MinValue, MaxValue가 뜻하는 것이 무엇인지?
minvalue maxvlue가 무엇을 의미하는지 알도록 한다.
public const int MaxValue = 2147483647;
public const int MinValue = -2147483648;
overflow, underflow를 유의한다.
Int32.MinValue부터 Int32.MaxValue까지의 null 또는 정수값을 Nullable<int>에 할당 가능


7. 인터페이스 구성 요소. 인터페이스에는 무엇 무엇이 들어갈 수 있다.
인터페이스는 메소드, 이벤트, 프로퍼티, 인덱서만을 가질 수 있다.
메인이프(메소드, 인덱서, 이벤트, 프로퍼티)

	함수, 속성, 이벤트, 인덱서
   day30 101줄
	interface ILogger
	{
		void WriteLog(string message);	// 메소드 정의. definition 없음. 추상 클래스의 abstract method와 유사
	}
	interface IFormattableLogger : ILogger
	{
	    void WriteLog(string format, params object[] args);
	}

	class ConsoleLogger : IFormattableLogger
	{
	    public void WriteLog(string message)
	    {
	        WriteLine("{0} {1}", DateTime.Now.ToLocalTime(), message);
	    }
	
	    public void WriteLog(string format, params Object[] args)
	    {
	        string message = String.Format(format, args);
	        Console.WriteLine("{0} {1}", DateTime.Now.ToLocalTime(), message);
	    }
	}



8. GetEnumerator 메소드 자체가 enumerator 타입을 리턴. 리턴하기 위해 호출할 때 하나씩 리턴해야 함.  yield
GetEnumerator() 메소드 구현 시 yield return 문의 도움을 받아야 한다.
yield return문은 현재 메소드의 실행을 일시 정지시켜 놓고 호출자에게 결과를 반환한다.
메소드가 다시 호출되면, 일시 정지된 실행을 복구하여 작업을 다시 실행한다.


9. C#의 여러 접근 제한자.public	: 클래스의 내부/외부 모든 곳에서 접근 가능
protected: 클래스의 외부에서는 접근할 수 없지만, 파생 클래스에서는 접근이 가능
private	: 클래스의 내부에서만 접근할 수 있다. 파생 클래스에서도 접근이 불가
internal	: 같은 어셈블리에 있는 코드에서만 public으로 접근 가능. 다른 어셈블리 코드에서는 private와 같은 수준의 접근성
protected internal : 같은 어셈블리에 있는 코드에서만 protected로 접근 가능. 다른 어셈블리 코드에선 private 수준
private protected : 같은 어셈블리에 있는 클래스에서 상속받은 클래스 내부에서만 접근이 가능


10. Generic 타입 변수 제한줄 때 where T
where T : struct 		: T는 값 형식이여야 한다.
where T : class  		: T는 참조 형식이어야 한다.
where T : new() 		: T는 반드시 매개 변수가 없는 생성자가 있어야 한다. (기본 생성자가 반드시 있어야 함)
where T : 기반 클래스 이름 	: T는 명시한 기반 클래스의 파생 클래스여야 한다.
where T : 인터페이스 이름 	: T는 명시한 인터페이스를 반드시 구현해야 한다. 여러개의 인터페이스를 명시 가능하다.
where T : U 		: T는 또다른 형식 매개 변수 U로부터 상속받은 클래스여야 한다.
   day31 279줄
	delegate int Compare<T>(T a, T b);

	static int AscendCompare<T>(T a, T b) where T : IComparable<T>
	{
		return a.CompareTo(b);
	}

	
11. 익명타입. 메인에서 직접 정의하던거
var myInstance = new { Name="사람", Age = "17"};
무명형식은 형식의 선언과 동시에 인스턴스를 할당.
무명형식의 프로퍼티에 할당된 값은 변경이 불가능하다. 읽기만 가능

Calculate calc;
calc = delegate (int a, int b)
{
    return a + b;
};
Console.WriteLine("3 + 4 : {0}", calc(3, 4));



12. new해서 객체 생성하는 문제
new로 생성 못하는것 : 인터페이스 , 추상클래스, 
DeepCopy, ShallowCopy
	class ShallowDeepCopy
	{
		public int field1;
		public int field2;

		public ShallowDeepCopy DeepCopy()
		{
			ShallowDeepCopy newClass = new ShallowDeepCopy();
			newClass.field1 = field1;
			newClass.field2 = field2;

			return newClass;
		}
	}

	static void Main(string[] args)
	{
		ShallowDeepCopy deepSource = new ShallowDeepCopy();
		deepSource.field1 = 10;
		deepSource.field2 = 20;

		ShallowDeepCopy deepTarget = deepSource.DeepCopy();
		deepTarget.field2 = 30;
	}

13. 상속과 생성자에 대해.
sealed : sealed 한정자로 클래스를 수식하면 상속 봉인이 되어 해당 클래스 상속 시도할 경우 에러 발생

연산자 is,as
is : 객체가 해당 형식에 해당하는지를 검사하여 결과를 bool값으로 반환
as : 형식 변환 연산자와 같은 역할을 한다. 형변환 연산자가 실패시 예외 던지는 반면 as는 객체 참조를 null로 만든다.

	static void Main(string[] args)
	{
		Mammal mammal = new Mammal();

		mammal = new Dog();

		if(mamml is Dog)
		{
			Dog dog = (Dog)mammal;	// 강제로 Dog로 캐스팅해야 Dog 메서드 사용 가능
			dog.Nurse();
			dog.Bark();
		}

		mammal = new Human();

		Human human = mammal as Human;	// mamml을 Human으로 형변환. 불가능한 경우 human은 null이 된다.
		if(human != null)
		{
			human.Nurse();
			human.Speak();
		}
	}		

virtual 키워드
: 가상 메소드로 설정해서 메소드 오버라이딩이 가능하게 해준다.
new
: 메소드 숨기기용으로 파생클래스 버전의 메소드를 new 한정자로 수식함으로 가능. 기반 클래스 구현 메소드를
감추고 파생 클래스 메소드만을 나타나게한다

   day29 109줄
	class ThisConstructor
	{
		public ThisContructor() {}
		public ThisConstructor(int b) : this() {}	// default 생성자 호출
		public ThisConstructor(int b, int c) : this(b) {}	// ThisConstructor(int b) 호출
	}


14. thread 중지할 수 있는 3가지 방법. (아닌 것을 고르시오.)	(종료)
14-1. flag
	static Boolean setStop = false;
	static void BlueFlagFlag()
	{
		while(!setStop)
		{
			Console.WrilteLine("청기");
			Thread.Sleep(10);
		}	
		Console.WriteLine("추가 작업");
	}

	static void Main(string[] args)
	{
		Thread thread = new Thread(new ThreadStart(BlueFlagFlag));	// ThreadStart: delegate
		thread.Start();

		setStop = ture;
		thread.Join();	// 위에 생성한 thread가 끝나길 main thread가 기다림
	}

14-2. abort
	메소드 호출 시 코드에 ThreadAbortException을 호출한다. catch, finally 거쳐서 종료된다.
	 자원 독점을 해제하지 않고 죽는 경우와 여러 문제가 있어서 권하지 않는 방법

	호출되는 순간 스레드가 종료됨.
	static void BlueFlagLoop()
	{
		try{
			while(true)
			{
				Thread.Sleep(10);
			}
		} catch (ThreadAbortException e)
		{
			Thread.ResetAbort();
		}
		finally
		{
			Console.WriteLine("리소스 해제");
		}
		Console.WriteLine("추가 작업");
	}

	static void Main(string[] args)
	{
		Thread thread = new Thread(new ThreadStart(BlueFlagLoop));
		thread.Start();

		thread.Abort();	// 스레드 중지
		thread.Join();
	}

14-3. interrupt
	스레드가 동작중인 상태를 피해서 WaitJoinSleep 상태에 들어갔을 때 ThreadInterruptedException 예외를 던져
	스레드를 중지시킨다. 이러한 특징 덕분에 중단되면 안되는 작업시, 중단이 되지 않는다는 보장을 받을 수 있다.	
	flag를 못 쓰는 상황에선 인터럽트 사용
	인터럽트되어도 반드시 실행되어야 하는 코드는 마무리되고 종료될 수 있도록,
	중간에 인터럽트되는 순간에 Thraed.Sleep()을 줘서 인터럽트되는 순간을 컨트롤할 수 있음.
	sleep 상태가 되고, wait sleep join 상태가 되면 그 때 interrupt 상태 (sleep 상태를 깨움)로 변경되어 종료될 수 있도록 함.
	
	static void BlueFlagInterrupt()
	{
		try{
			while(true)
			{
				Thread.Sleep(10);
			}
		} catch(ThreadInterruptedException e)
		{
			Console.WriteLine(e);
		}
		finally
		{
			Console.WriteLine("리소스 해제");
		}
		Console.WriteLine("추가 작업");
	}

	static void Main(string[] args)
	{
		Thread thread = new Thread(new ThreadStart(BlueFlagInterrupt));
		thread.Start();

		Thread.Sleep(100);

		thread.Interrupt();
		thread.Join();
	}
	

15. 어셈블리 문제 (dll 생성)
global assembly cache
글로벌 어셈블리 캐쉬라는 영역이 존재.
서명이 존재하는 dll만 등록이 가능하다. key 파일이 존재하면 자유롭게 dll 
수정가능 128비트 암호화 되어있으므로 해킹도 힘듬


16-20. thread task 문제. task가 포함돼서 thread 문제 다섯개
async, await Task

day32 436줄. 비동기 copy
Action<object> FileCopyAction = (object state) =>
{
	string[] path = (string[])state;
	File.Copy(paths[0], paths[1]);
};

Task t1 = new Task(FileCopyAction, new string[] {srcFile, srcFile + ".copy1"});
t1.Start();	// 비동기적으로 실행시키고 아래 코드로 넘어감.

Task t2 = Task.Run( () =>
{
	FileCopyAction(new string[] {srcFile, srcFile + ".copy2" });
});

Task t3 = new Task(FileCopyAction, new string[] {srcFile, srcFile + ".copy3"});
t3.RunSynchronously();	// 동기방식으로 실행

t1.Wait();
t2.Wait();



/// Task List
long from = Convert.ToInt64(args[0]);
long to = Convert.ToInt64(args[1]);
int taskCount = Convert.ToInt32(args[2]);

Func<object, List<long>> FindPrimeFunc = (objRange) =>
{
	long[] range = (long[]) objRange;
}


/// async, await
Task, Task<TResult>, void

async static private void MyMethodAsync(int count)
{
	"B";

	await Task.Run( () =>
	{
		for(int i=1; i<= count; i++)
		{
			"...";
			Thread.Sleep(100);
		}
	});

	"D";
}

static void Caller()
{
	"A";
	MyMethodAsync(3);
	"C";

}




Parellel.For(
일반 메소드를 

<async, await>
- async: 메소드, 이벤트처리기, 태스크, 람다식
- async로 한정하는 메소드는 반드시!!!!!!!!!!!! 반환형식이 Task, Task<TResult> 또는 void여야 함. (문제 하나 나옴)
- Task, Task<TResult> 타입 메소드는 메소드 내부에 await 연산자를 만나면 호출자에게 제어권 넘김
	(await 연산자가 없으면 동기방식으로 진행)